---
source: Rmd
title: "Overview of scRNA-seq Data"
teaching: 10
exercises: 2
questions:
- "What does single cell RNA-Seq data look like?"
objectives:
- "Understand the types of files provided by CellRanger."
- "Understand the structure of files provided by CellRanger."
- "Describe a sparse matrix and explain why it is useful."
- "Read in a count matrix using Seurat."
keypoints:
- "CellRanger produces a gene expression count matrix that can be read in using Seurat."
- "The count matrix is stored as a sparse matrix with features in rows and cells in columns."
---

```{r setup, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("03-")
```

```{r libs,warning=FALSE}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(Seurat))

data_dir <- '../data'
```

## Open Project File

In the Setup section of this workshop, you created an RStudio Project. Open this project now, by:

1. selecting File --> Open Project... from the Menu,
2. choosing "scRNA.Rproj" , 
3. opening the project file.

## What files are delivered? Details of FASTQ, etc.

The raw data for an scRNA-Seq experiment typically consists of two FASTQ files.
[Describe further]

DAS -- NB SCBL provides CellRanger results as well. See next section.

## Typical pre-processing pipeline

### 10X CellRanger

 * What is CellRanger?
 * Produces gene counts for each cell.

### CellRanger alternatives

 * alevin
 * STARsolo

## Intro to two major single cell analysis ecosystems: 

At the time that this workshop was created, there were many different software packages designed for analyzing scRNA-seq data in a variety of scenarios. The two scRNA-seq software "ecosystems" that were most widely in use were:

* R/Seurat : Focus of this workshop. Biggest strength is straightforward vignettes and ease of visualization/exploration. 
    * [Seurat](https://www.nature.com/articles/nbt.3192) was released in 2015 by the [Regev lab](https://biology.mit.edu/profile/aviv-regev/).
    * The first author, Rahul Satija, now has a faculty position and has maintained and improved Seurat.
    * Currently at [version 4](https://www.cell.com/cell/fulltext/S0092-8674(21)00583-3).
    * Source code available on [Github](https://www.github.com/satijalab/seurat).
    * Seurat v1: Infers cellular localization by integrating scRNA-seq with *in situ* hybridization.
    * Seurat v2: Integrates multiple scRNA-seq data sets using shared correlation structure.
    * Seurat v3: Integrates data from multiple technologies, i.e. scRNA-seq, scATAC-seq, proteomics, *in situ* hybridization.
    * Seurat v4: Integrative multimodal analysis and mapping of user data sets to cell identity reference database.

* Python/scanpy
    * DAS: Expand on this.

## Reading in CellRanger Data

[CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger) is software which analyzes Chromium single cell data to 
align reads, generates feature-bar code matrices, and perform other downstream 
analyses. 
[DAS add a sentence on what a feature barcode matrix is. In this context gene expression.]
CellRanger is provided by 10X Genomics. In this workshop, we will read in the 
feature-bar code matrix produced by CellRanger and will perform the downstream 
analysis using Seurat.

### Liver Atlas

In this lesson, we will read in a subset of data from the 
[Liver Atlas](https://livercellatlas.org/index.php), which is described in their 
[Cell paper](https://www.cell.com/cell/fulltext/S0092-8674(21)01481-1). 
Briefly, the authors performed scRNASeq on liver cells from mice and humans, 
identified cell types, clustered them, and made the data publicly available. 
We will be working with a subset of the *mouse* liver data. 
We split the data into two sets, one to use in the lesson and one for 
you to work with independently as a challenge. We have also sub-sampled each 
data subset to contain 75% of the cells to reduce memory usage and speed up the 
analysis time for this workshop.

Before the workshop, you should have downloaded the data from 
<NEED TO FILL THIS IN> and placed it in your `data` directory. 
Go to the [Setup](../setup) page for instructions on how to download the data 
files.

Open a file browser and look in the `data` subdirectory `mouseStSt_invivo` and 
you should see three files. Each file ends with 'gz', which indicates that it 
has been compressed (or 'zipped') using 
[gzip](https://www.gnu.org/software/gzip/). You **don't** need to unzip them; 
the software that we use will uncompress the files as it reads them in. The 
files are:

* matrix.mtx.gz: Two-dimensional matrix containing the counts for each gene in each cell.
    * Genes are in rows and cells are in columns.
    * This file is in a special sparse matrix format which reduces disk space and memory usage.
* barcodes.tsv.gz: DNA barcodes for each cell. Used as column names in counts matrix.
* features.tsv.gz: Gene symbols for each gene. Used as row names in counts matrix.

![Counts Matrix](../fig/counts_matrix.png)

> ## Challenge 1
> 1). R has a function called [file.size](https://stat.ethz.ch/R-manual/R-devel/library/base/html/file.info.html). Look at the help for this function and get the size of each of the files in the `mouseStSt_invivo` directory.  Which one is the largest?  
>
> > ## Solution to Challenge 1
> >
> > 1). `file.size(file.path(data_dir, 'mouseStSt_invivo', 'barcodes.tsv.gz'))`  
> >     584346 bytes  
> >     `file.size(file.path(data_dir, 'mouseStSt_invivo', 'features.tsv.gz'))`  
> >     113733 bytes  
> >     `file.size(file.path(data_dir, 'mouseStSt_invivo', 'matrix.mtx.gz'))`  
> >     603248953 bytes  
> >     'matrix.mtx.gz' is the largest file.     
> {: .solution}
{: .challenge}

### Reading a CellRanger Gene Expression Count Matrix using Seurat

In order to read these files into memory, we will use the 
[Seurat::Read10X()](https://satijalab.org/seurat/reference/read10x) function. 
This function searches for the three files mentioned above in the directory that
you pass in. Once it verifies that all three files are present, it reads them 
in to create a counts matrix with genes in rows and cells in columns.

We will use the `gene.column = 1` argument to tell Seurat to use the first 
column in 'features.tsv.gz' as the gene identifier.

Run the following command. This may take up to three minutes to complete.

```{r read_counts}
# uses the Seurat function Read10X()
counts <- Read10X(file.path(data_dir, 'mouseStSt_invivo'), gene.column = 1)
```

`counts` now contains the sequencing read counts for each gene and cell.

How many rows and columns are there in `counts`?

```{r dim_counts}
dim(counts)
```

In the `counts` matrix, genes are in rows and cells are in columns. Let's look 
at the first few gene names.

```{r rownames_counts}
head(rownames(counts), n = 10)
```

As you can see, the gene names are gene symbols. There is some risk that these 
may not be unique. Let's check whether any of the gene symbols are duplicated. 
We will sum the number of duplicated gene symbols.

```{r duplicated_symbol}
sum(duplicated(rownames(counts)))
```

The sum equals zero, so there are no duplicated gene symbols, which is good.
As it turns out, the reference genome/annotation files that are prepared for
use by CellRanger have already been filtered to ensure no duplicated gene
symbols. 

Let's look at the cell identifiers in the column names.

```{r colnames_counts}
head(colnames(counts), n = 10)
```

Each of these barcodes identifies one cell. They should all be unique. Once 
again, let's verify this.

```{r barcodes_unique}
sum(duplicated(colnames(counts)))
```

The sum of duplicated values equals zero, so all of the barcodes are unique.
The barcode sequence is the actual sequence of the oligonucleotide tag that
was stuck to the GEM (barcoded bead) that went into each droplet. In early
versions of 10X technology there were approximately 
[750,000 barcodes](https://kb.10xgenomics.com/hc/en-us/articles/115004506263-What-is-a-barcode-whitelist-) 
per run while in the current chemistry there are 
[>3 million barcodes](https://kb.10xgenomics.com/hc/en-us/articles/360031133451-Why-is-there-a-discrepancy-in-the-3M-february-2018-txt-barcode-whitelist-).
CellRanger attempts to correct sequencing errors in the barcodes
and uses a "whitelist" of known barcodes (in the 10X chemistry) to help.


Next, let's look at the values in `counts`.

```{r view_counts}
counts[1:10, 1:20]
```

We can see the gene symbols in rows along the left. The barcodes are not shown 
to make the values easier to read. Each of the periods represents a zero. The 
'1' values represent a single read for a gene in one cell.

Although `counts` looks like a matrix and you can use many matrix functions on 
it, `counts` is actually a *different* type of object. In scRNASeq, the read 
depth in each cell is quite low. So you many only get counts for a small number 
of genes in each cell. The `counts` matrix has `r nrow(counts)` rows and 
`r ncol(counts)`, and includes `r exp(log(nrow(counts)) + log(ncol(counts)))` 
entries. However, most of these entries 
(`r sum(counts == 0) / exp(log(nrow(counts)) + log(ncol(counts))) * 100`%) are 
zeros because every gene is not detected in every cell. It would be wasteful 
to store all of these zeros in memory. It would also make it difficult to 
store all of the data in memory. So `counts` is a 'sparse matrix', which only 
stores the positions of non-zero values in memory.

Look at the structure of the `counts` matrix using [str](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/str.html). 

```{r counts_class}
str(counts)
```

We can see that the formal class name is a "dgCMatrix". There are two long 
vectors of integers which encode the positions of non-zero values. The gene 
names and cell barcodes are stored in character vectors and the non-zero values 
are an integer vector. This class saves space by not allocating memory to store 
all of the zero values.

Let's look at small portion of `counts`. We will create a tile plot indicating 
which values are non-zero for the first 100 cells and genes in rows 400 to 600. 
For historical reasons, R plots the rows along the X-axis and columns along the 
Y-axis. We will transpose the matrix so that genes are on the Y-axis, which 
reflects the way in which we normally look at this matrix.

```{r counts_image,fig.height=6}
image(1:100, 400:600, t(as.matrix(counts[400:600,1:100]) > 0), xlab = 'Cells', ylab = 'Genes')
```

In the tile plot above, each row represents one gene and each column represents 
one cell. Red indicates non-zero values and yellow indicates zero values.  As 
you can see, most of the matrix consists of zeros (yellow tiles) and hence is 
called 'sparse'. You can also see that some genes are expressed in most cells, 
indicated by the horizontal red lines, and that some genes are expressed in 
very few cells.

What proportion of genes have zero counts in all samples? 

```{r gene_sums}
gene_sums <- data.frame(gene_id = rownames(counts),
                        sums    = rowSums(counts))
sum(gene_sums$sums == 0)
```

We can see that `r sum(gene_sums$sums == 0)` (`r mean(gene_sums$sums == 0)`%) 
genes have no reads at all associated with them. In the next lesson, we will 
remove genes that have no counts in any cells.

Next, let's look at the number of counts in each cell.

```{r cell_counts}
hist(colSums(counts))
```

The range of counts covers several orders of magnitude, from 
`r min(colSums(counts))` to `r max(colSums(counts))`. 

TBD: What do we say here? How does scRNAseq handle coverage?

### Sample Metadata

Sample metadata refers to information about your samples that is not the 
"data", i.e. the gene counts. This might include information such as sex, 
tissue, or treatment. In the case of the liver atlas data, the authors provided 
a metadata file for their samples.

The sample metadata file is a comma-separated variable (CSV) file, We will read 
it in using the readr 
[read_csv](https://readr.tidyverse.org/reference/read_delim.html) function.

> TBD: Use a metadata file that does NOT have cell identities & UMAP coordinates here? Then reveal the full one later.

```{r read_metadata}
metadata <- read_csv(file.path(data_dir, 'mouseStSt_invivo', 'annot_metadata.csv'))
```

Let's look at the top of the metadata.

```{r head_metadata}
head(metadata)
```

In the table above, you can see that there are four columns:

1. sample: mouse identifier from which cell was derived;
1. cell: the DNA bar code used to identify the cell;
1. digest: either "inVivo" or "exVivo". whether the cells were harvested *in vivo* or *ex vivo*,
1. typeSample: either "scRnaSeq" or "nucSeq". The type of library preparation protocol, either single cell RNA-seq or nuclear sequencing.

Let's look at how many cells we have from each digest type
and library preparation method:

```{r cell_classes}
with(metadata, table(digest, typeSample))
```

We're going to explore the data further using a series of Challenges. 
You will be asked to look at the contents of some of the columns to see 
how the data are 
distributed.

> ## Challenge 2
> How many mice were used to produce this data? The "sample" column contains the mouse identifier for each cell.  
>
> > ## Solution to Challenge 2
> >
> > count(metadata, sample) %>% summarize(total <- n())     
> {: .solution}
{: .challenge}


> ## Challenge 3
> There were two digests, inVivo and exVivo. How many cells are there from each mouse in each digestion? 
>
> > ## Solution to Challenge 3
> >
> > count(metadata, sample, digest)  
> > From this, we can see that each mouse was used for only one type of digestion, either inVivo or exVivo.
> {: .solution}
{: .challenge}


> ## Challenge 4
> There were also two types of library preparation, indicated by the "typeSample" column. How many cells were derived from each digestion and library preparation protocol?
>
> > ## Solution to Challenge 4
> >
> > count(metadata, digest, typeSample)  
> > From this, we can see that ther are between 15 and 75 thousand cells in each class.
> {: .solution}
{: .challenge}

> TBD: Use a treemap to look at the proportion of samples from each digest/protocol? It's not required, but could be fun.

In this workshop, we will attempt to reproduce some of the results of the 
[Liver Atlas](https://livercellatlas.org/index.php) using Seurat. We will 
analyze the *in-vivo* single **cell** RNA-Seq and single **nucleus** RNA-Seq 
data together and you will analyze some separate *ex-vivo* data during 
Challenges.

> TBD: explain differences between scRNASeq, citeSeq & nucSeq? Briefly?

### Save Data for Next Lesson

We will use the *in-vivo* data in the next lesson. Save it now and we will 
load it at the beginning of the next lesson. We will use R's [save](https://stat.ethz.ch/R-manual/R-devel/library/base/html/save.html) 
command to save the objects in compressed, binary format. The `save` command is 
useful when you want to save multiple objects in one file.

```{r save_data}
save(counts, metadata, file <- file.path(data_dir, 'lesson03.Rdata'))
```

> ## Challenge 5
> In the lesson above, you read in the scRNASeq and nucSeq data. There is another dataset which was created using "citeSeq" in the `mouseStSt_citeseq_75pct` directory. Delete the `counts` and `metadata` objects from your environment. Then read in the counts and metadata from the `mouseStSt_citeseq_75pct` directory and save them to a file called 'lesson03_challenge.Rdata'.
>
> > ## Solution to Challenge 5
> >
> > `# Remove exising counts and metadata.`  
> > `rm(counts, metadata)`
> > `# Read in new counts.`  
> > `counts <- Seurat::Read10X(file.path(data_dir, 'mouseStSt_citeseq_75pct'), gene.column <- 1)`  
> > `# Read in new metadata.`  
> > `metadata <- read_csv(file.path(data_dir, 'mouseStSt_citeseq_75pct', 'annot_metadata.csv'))`  
> > `# Save data for next lesson.`  
> > `save(counts, metadata, file <- file.path(data_dir, 'lesson03_challenge.Rdata'))`  
> {: .solution}
{: .challenge}

### Session Info

```{r session_info}
sessionInfo()
```


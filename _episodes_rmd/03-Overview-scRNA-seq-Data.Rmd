---
source: Rmd
title: "Overview of scRNA-seq Data"
teaching: 10
exercises: 2
questions:
- "What does single cell RNAseq data look like?"
objectives:
- "Explain how to use RMarkdown with the new lesson template."
- "Demonstrate how to include pieces of code, figures, and challenges."
keypoints:
- "Edit the .Rmd files not the .md files"
- "Run `make serve` to knit documents and preview lesson website locally"
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("03-")

library(Seurat)

base_dir = 'C:/Users/c-dgatti/Documents/classes/JAX/scRNAseq/SingleCellRNAseq'
data_dir = file.path(base_dir, 'data')
```

## What files are delivered? Details of FASTQ, etc.



## Typical pre-processing pipeline -- 10X CellRanger 


## Intro to two major single cell ecosystems: 

* R/Seurat : major focus of this workshop. Biggest strength is straightforward vignettes and ease of visualization/exploration 
* Python/scanpy

## Reading in CellRanger Data

### Liver Atlas

In this lesson, we will read in a subset of data from the [Liver Atlas](https://livercellatlas.org/index.php), which is described in their [Cell paper](https://www.cell.com/cell/fulltext/S0092-8674(21)01481-1). Briefly, the authors performed scRNASeq on liver cells from mice and humans, identified cell types, clustered them, and made the data publicly available. We have subsampled this data to contain 25% of the cells in the original analysis to reduce memory usage and speed up the analysis time for this workshop.

We will be working with a subset of the mouse liver data. Before the workshop, you should have downloaded the data from <NEED TO FILL THIS IN> and placed it in your `data` directory. Go to the [Setup](../setup) page for instuctions on how to download the data files.

> TBD: Not sure where to host the files. Box requires a complex authentication process that I don't want to put the users through. Maybe we put the data on figshare?

Open a file browser and look in the `mouseStSt25pct` directory and you should see three files. Each file ends with 'gz', which indicates that it has been compressed (or 'zipped') using [gzip](https://www.gnu.org/software/gzip/). You **don't** need to unzip them; the software that we use will uncompress the files as it reads them in. The files are:

* matrix.mtx.gz: Two-dimensional matrix containing the counts for each gene in each cell.
    * Genes are in rows and cells are in columns.
    * This file is in a special sparse matrix format which reduces memory usage.
* barcodes.tsv.gz: DNA barcodes for each cell. Used as column names in counts matrix.
* features.tsv.gz: Gene symbols for each gene. Used as row names in counts matrix.

![Counts Matrix](../fig/counts_matrix.png)

> ## Challenge 1
> 1). R has a function called [file.size](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/file.info). Look at the help for this function and get the size of each of the files in the `mouseStSt25pct` directory.  Which one is the largest?  
>
> > ## Solution to Challenge 1
> >
> > 1). `file.size(file.path(data_dir, 'mouseStSt25pct', 'barcodes.tsv.gz'))`
> >     584346
> >     `file.size(file.path(data_dir, 'mouseStSt25pct', 'features.tsv.gz'))`
> >     113733
> >     `file.size(file.path(data_dir, 'mouseStSt25pct', 'matrix.mtx.gz'))`
> >     603248953
> >     'matrix.mtx.gz' is the largest file.   
> {: .solution}
{: .challenge}

In order to read these files into memory, we will use the [Seurat::Read10X()](https://satijalab.org/seurat/reference/read10x) function. This function searches for the three files mentioned above in the directory that you pass in. Once it verifies that all three files are present, it reads them in to create a counts matrix with genes in rows and cells in columns.

We will use the `gene.column = 1` argument to tell Seurat to use the first column in 'features.tsv.gz' as the gene identifier.

Run the following command. This may take up to 3 minutes to complete.

```{r read_counts}
counts = Seurat::Read10X(file.path(data_dir, 'mouseStSt25pct'), gene.column = 1)
```

`counts` now contains the sequencing read counts for each gene and cell.

How many rows and columns are there in `counts`?

```{r dim_counts}
dim(counts)
```

In the `counts` matrix, genes are in rows and cells are in columns. Let's look at the first few gene names.

```{r rownames_counts}
head(rownames(counts), n = 10)
```

As you can see, the gene names are gene symbols. There is some risk that these may not be unique. Let's check whether any of the gene symbols are duplicated. We will sum the number of duplicated gene symbols.

```{r duplicated_symbol}
sum(duplicated(rownames(counts)))
```

The sum equals zero, so there are no duplicated gene symbols, which is good.

Let's look at the cell identifiers in the column names.

```{r colnames_counts}
head(colnames(counts), n = 10)
```

Each of these barcodes identifies one cell. They should all be unique. Once again, let's verify this.

```{r barcodes_unique}
sum(duplicated(colnames(counts)))
```

The sum of duplicated values equals zero, so all of the barcodes are unique.

Next, let's look at the values in `counts`.

```{r view_counts}
counts[1:10, 1:20]
```

We can see the gene symbols in rows along the left. The barcodes are not shown to make the values easier to read. Each of the periods represents a zero. The '1' values represent a single read for a gene in one cell.

Although `counts` looks like a matrix and you can use many matrix functions on it, `counts` is actually a different type of object. In scRNASeq, the read depth in each cell is quite low. So you many only get counts for a small number of genes in each cell. The `counts` matrix has `r nrow(counts)` rows and `r ncol(counts)`, and includes `r nrow(counts) * ncol(counts)` entries. However, most of these entries are zeros because every gene is not detected in every cell. It would be wasteful to store all of these zeros in memory. It would also make it difficult to store all of the data in memory. So `counts` is a 'sparse matrix', which only stores the positions of non-zero values in memory.

Let's look at small portion of `counts`. We will create a tile plot indicating which values are non-zero for the first 100 cells and genes in rows 400 to 600.

```{r counts_image,fig.height=4}
image(1:100, 400:600, t(as.matrix(counts[400:600,1:100]) > 0), xlab = 'Cells', ylab = 'Genes')
```

In the plot above, red indicates non-zero values and yellow indicates zero values. As you can see, most of the matrix consists of zeros and hence is called 'sparse'.

What proportion of genes have zero counts in each sample? To answer this question, we will get the mean of the number of zeros in the first 10,000 cells. We will no

```{r}
hist(colMeans(counts[,1:10000] == 0))
```

